#!/usr/bin/lua

local wireless = require 'gluon.wireless'

local uci = require('simple-uci').cursor()

local function is_disabled_wireless(name)
	if uci:get('wireless', name) then
		return uci:get_bool('wireless', name, 'disabled')
	end

	return nil
end

local function is_disabled(config, name)
	local disabled = is_disabled_wireless(name)

	if disabled == nil then
		return config.disabled(false)
	end

	return disabled
end

-- if there is a radio which does not support the mesh channel, we can configure it on a different channel
-- in this case, the other radio on the same band supporting the channel turns off its client radio and is mesh only
local has_client_only_radio = false

local function configure_ap(radio, index, config, radio_name)
	local name = 'client_' .. radio_name
	local suffix = radio_name:match('^radio(%d+)$')

	local ap = config.ap
	local disabled = is_disabled(ap, name)

	if not wireless.supports_channel(radio, config.channel()) then
		has_client_only_radio = true
	end

	uci:delete('wireless', name)

	local macaddr = wireless.get_wlan_mac('client', index, radio)

	if not ap.ssid() or not macaddr then
		return
	end

	uci:section('wireless', 'wifi-iface', name, {
		device = radio_name,
		network = 'client',
		mode = 'ap',
		ssid = ap.ssid(),
		macaddr = macaddr,
		ifname = suffix and 'client' .. suffix,
		disabled = disabled or false,
	})
end

local function configure_owe(radio, index, config, radio_name)
	local name = 'owe_' .. radio_name
	local suffix = radio_name:match('^radio(%d+)$')

	local ap = config.ap

	local disabled = is_disabled(ap, 'client_' .. radio_name)

	uci:delete('wireless', name)

	-- Don't configure OWE in case our device
	-- can't do MFP, as it's mandatory for OWE.
	if not wireless.device_supports_mfp(uci) then
		return
	end

	local macaddr = wireless.get_wlan_mac('mesh', index, radio)

	if not ap.owe_ssid() or not macaddr then
		return
	end

	uci:section('wireless', 'wifi-iface', name, {
		device = radio_name,
		network = 'client',
		mode = 'ap',
		ssid = ap.owe_ssid(),
		macaddr = macaddr,
		ifname = suffix and 'owe' .. suffix,
		disabled = disabled or false,
		encryption = 'owe',
		ieee80211w = 2,
	})
end

local function configure_owe_transition_mode(config, radio_name)
	local ap = config.ap

	-- Don't configure OWE in case our device
	-- can't do MFP, as it's mandatory for OWE.
	if not wireless.device_supports_mfp(uci) then
		return
	end

	if not ap.owe_transition_mode(false) then
		return
	end

	local name_client = 'client_' .. radio_name
	local name_owe = 'owe_' .. radio_name

	local ifname_client = uci:get('wireless', name_client, 'ifname')
	local ifname_owe = uci:get('wireless', name_owe, 'ifname')

	if not (ifname_client and ifname_owe) then
		return
	end

	uci:set('wireless', name_client, 'owe_transition_ifname', ifname_owe)
	uci:set('wireless', name_owe, 'owe_transition_ifname', ifname_client)

	uci:set('wireless', name_owe, 'hidden', '1')
end

wireless.foreach_radio(uci, function(radio, index, config)
	local radio_name = radio['.name']

	configure_ap(radio, index, config, radio_name)

	configure_owe(radio, index, config, radio_name)
	configure_owe_transition_mode(config, radio_name)
end)

-- Assign mesh radio and client radio to separate 5GHz radios if at least
-- two exist and one of them doesn't support mesh channels.
-- Let the one(s) that don't support mesh channels run as client radio and
-- run mesh radio on all remaining 5GHz radios.
if has_client_only_radio then
	wireless.foreach_radio(uci, function(radio, _, config)
		local radio_name = radio['.name']

		if is_disabled_wireless(radio_name) == nil then
			local name = 'client_' .. radio_name
			-- disable client radio on the 5GHz band which supports the mesh channel
			if wireless.supports_channel(radio, config.channel()) and radio.band == '5g' then
				uci:set('wireless', name, 'disabled', true)
			end
		end
	end)
end

uci:save('wireless')
